<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI-Assisted SLR Screener</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- PDF.js for client-side PDF parsing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <!-- Use Inter font -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f9fb;
        }
        .scroll-container {
            max-height: 70vh;
            overflow-y: auto;
            border: 1px solid #e5e7eb;
            background-color: white;
            padding: 1rem;
        }
        .article-card {
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.06);
            transition: transform 0.2s;
        }
        .article-card:hover {
            transform: translateY(-2px);
        }
        /* Custom styling for the report output */
        #slr-draft-output {
            white-space: pre-wrap;
            font-family: 'Inter', sans-serif; 
            text-align: left;
        }
        /* Style for Markdown headings converted to HTML */
        #slr-draft-output h1, #slr-draft-output h2, #slr-draft-output h3 {
            font-weight: bold;
            margin-top: 1.5rem;
            margin-bottom: 0.5rem;
            border-bottom: 1px solid #ddd;
        }
        #slr-draft-output h1 { font-size: 2rem; }
        #slr-draft-output h2 { font-size: 1.5rem; }
        #slr-draft-output h3 { font-size: 1.25rem; }

        /* --- Styles for Document Uploader --- */
        .file-upload-label {
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .file-upload-label:hover {
            box-shadow: 0 4px 15px -3px rgba(59, 130, 246, 0.5); /* blue-500 shadow */
            transform: translateY(-1px);
        }
        /* Custom scrollbar for better visual on preview area */
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #cbd5e1; /* slate-300 */
            border-radius: 4px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #94a3b8; /* slate-400 */
        }
    </style>
</head>
<body>
    <div class="max-w-6xl mx-auto p-4 sm:p-6 lg:p-8">
        <header class="text-center mb-8 p-6 bg-white rounded-xl shadow-lg">
            <h1 class="text-4xl font-extrabold text-blue-800">AI-Assisted SLR Screener</h1>
            <p class="text-lg text-gray-600 mt-2">Automate initial article screening using PubMed and Gemini.</p>
        </header>

        <!-- Search Form & Criteria Panel (Step 1) -->
        <div id="input-panel" class="bg-white p-6 rounded-xl shadow-lg mb-8">
            <h2 class="text-2xl font-semibold text-gray-800 mb-4 border-b pb-2">1. Define Research Question & Date Range</h2>
            <form id="criteria-form">
                <div class="mb-6">
                    <label for="research-question" class="block text-sm font-medium text-gray-700 mb-1">Enter your Research Question or PICO Structure:</label>
                    <textarea id="research-question" rows="4" required
                              class="w-full p-3 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 transition duration-150"
                              placeholder="Example: What is the efficacy of large language models (LLMs) in improving diagnostic accuracy among primary care physicians?">What are the benefits and risks of different immunotherapy drugs for treating glioblastoma?</textarea>
                </div>
                <div class="mb-6">
                    <label for="date-limit" class="block text-sm font-medium text-gray-700 mb-1">Date Limit (Optional): Only include articles published *since* this year (e.g., 2023)</label>
                    <input type="number" id="date-limit" min="1900" max="2099" 
                           class="w-full p-3 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 transition duration-150"
                           placeholder="Leave empty for no date limit">
                </div>
                <button type="submit" id="generate-button"
                        class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-4 rounded-lg transition duration-200 focus:outline-none focus:ring-4 focus:ring-blue-300">
                    Generate Criteria & PubMed Query
                </button>
            </form>
        </div>
        
        <!-- System Messages & Loading Indicator -->
        <div id="status-message" class="text-center text-lg font-medium py-4 rounded-lg shadow-inner hidden"></div>


        <!-- Criteria Review and Screening Panel (Step 2) -->
        <div id="review-panel" class="bg-white p-6 rounded-xl shadow-lg mb-8 hidden">
            <h2 class="text-2xl font-semibold text-gray-800 mb-4 border-b pb-2">2. Review & Refine Criteria</h2>
            
            <!-- PICO Analysis Display -->
            <div id="pico-container" class="mb-6 p-4 bg-blue-50 rounded-lg border border-blue-200 hidden">
                <h3 class="text-lg font-semibold text-blue-900 mb-3 flex items-center">
                    <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-3 7h3m-3 4h3m-6-4h.01M9 16h.01"></path></svg>
                    AI-Generated PICO Analysis
                </h3>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm">
                    <div class="bg-white p-3 rounded shadow-sm border-l-4 border-blue-500">
                        <span class="block font-bold text-gray-500 text-xs uppercase tracking-wider">Population (P)</span>
                        <span id="pico-p" class="text-gray-800 font-medium">Loading...</span>
                    </div>
                    <div class="bg-white p-3 rounded shadow-sm border-l-4 border-green-500">
                        <span class="block font-bold text-gray-500 text-xs uppercase tracking-wider">Intervention (I)</span>
                        <span id="pico-i" class="text-gray-800 font-medium">Loading...</span>
                    </div>
                    <div class="bg-white p-3 rounded shadow-sm border-l-4 border-orange-500">
                        <span class="block font-bold text-gray-500 text-xs uppercase tracking-wider">Comparison (C)</span>
                        <span id="pico-c" class="text-gray-800 font-medium">Loading...</span>
                    </div>
                    <div class="bg-white p-3 rounded shadow-sm border-l-4 border-purple-500">
                        <span class="block font-bold text-gray-500 text-xs uppercase tracking-wider">Outcome (O)</span>
                        <span id="pico-o" class="text-gray-800 font-medium">Loading...</span>
                    </div>
                </div>
            </div>

            <form id="screening-form">
                <div class="mb-4">
                    <label for="pubmed-query" class="block text-sm font-medium text-gray-700 mb-1">Suggested PubMed Query (Edit if needed)</label>
                    <input type="text" id="pubmed-query" required
                           class="w-full p-3 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 transition duration-150">
                </div>

                <div class="mb-6">
                    <label for="inclusion-criteria" class="block text-sm font-medium text-gray-700 mb-1">Inclusion/Exclusion Criteria (Edit if needed - JSON Format)</label>
                    <textarea id="inclusion-criteria" rows="6" required
                              class="w-full p-3 border border-gray-300 rounded-lg font-mono text-sm focus:ring-blue-500 focus:border-blue-500 transition duration-150">
<!-- Generated content goes here -->
</textarea>
                </div>
                
                <button type="submit" id="start-screening-button"
                        class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-4 rounded-lg transition duration-200 focus:outline-none focus:ring-4 focus:ring-green-300">
                    Start AI Abstract Screening (Fetch Articles)
                </button>
            </form>
        </div>


        <!-- Results Panel (Step 3) -->
        <div id="results-panel" class="hidden">
            <h2 class="text-3xl font-bold text-gray-800 mb-6 border-b-4 border-blue-200 pb-2">3. Abstract Screening Results</h2>
            
            <!-- LLM Included List -->
            <div class="mb-8">
                <h3 class="text-2xl font-semibold text-green-700 mb-3 flex items-center">
                    <svg class="w-6 h-6 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                    Included by Abstract (<span id="included-count">0</span>)
                </h3>
                <p class="text-gray-500 mb-3">These articles meet your criteria and are ready for full text review or data extraction.</p>
                <div id="included-list" class="scroll-container grid gap-4 grid-cols-1 md:grid-cols-2">
                    <!-- Articles go here -->
                </div>
            </div>

            <!-- LLM Excluded (Needs Review) List -->
            <div>
                <h3 class="text-2xl font-semibold text-red-600 mb-3 flex items-center">
                    <svg class="w-6 h-6 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                    Excluded by Abstract (Review Required) (<span id="excluded-count">0</span>)
                </h3>
                <p class="text-gray-500 mb-3">Review these to see if the AI was wrong and use the 'Override' button if needed.</p>
                <div id="excluded-list" class="scroll-container grid gap-4 grid-cols-1 md:grid-cols-2">
                    <!-- Articles go here -->
                </div>
            </div>
            
             <button onclick="window.exportResults()" 
                    class="mt-8 w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-4 rounded-lg transition duration-200 focus:outline-none focus:ring-4 focus:ring-indigo-300">
                    Export Abstract Screening Results (JSON)
            </button>
        </div>
        
        <!-- Document Upload Panel (Step 4) -->
        <div id="upload-panel" class="bg-white p-6 rounded-xl shadow-lg mt-8 hidden">
            <h2 class="text-2xl font-semibold text-gray-800 mb-4 border-b pb-2">4. Full Text Retrieval Status & Upload</h2>
            <p class="text-gray-500 mb-4">The system has attempted to automatically retrieve full text for open-access articles. Please **manually upload** any remaining paywalled articles corresponding to your included PMIDs.</p>
            
            <div id="retrieval-status-message" class="mb-4 p-3 rounded-lg bg-yellow-50 text-yellow-800 font-medium hidden"></div>

            <div class="border-2 border-dashed border-purple-200 p-6 rounded-xl bg-purple-50">
                <input type="file" id="fileInput" accept=".txt,.md,.log,.csv,.pdf" multiple class="hidden" onchange="window.handleFileSelect()">

                <label for="fileInput" class="file-upload-label flex flex-col items-center justify-center p-8 border-4 border-purple-500 rounded-lg bg-purple-100 text-purple-700 hover:bg-purple-200 transition-colors duration-200">
                    <svg class="w-12 h-12 mb-3" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.884-7.904A5 5 0 0115 5a4 4 0 01.442 7.91l-1.074.214a1 1 0 00-.773.96l-.001 1.054a1 1 0 00.773.96l2.149.429a1 1 0 01.773.96v1.054a1 1 0 00.773.96l-1.074.214A4 4 0 0117 21a4 4 0 01-4-4v-1.054a1 1 0 00-.773-.96l-2.149-.429a1 1 0 01-.773-.96v-1.054a1 1 0 00-.773-.96l-1.074-.214A4 4 0 017 16z"></path>
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 17v-8m0 0l-3 3m3-3l3 3"></path>
                    </svg>
                    <span class="text-lg font-semibold">Click here to upload files (PMID in filename)</span>
                    <span class="text-sm font-medium text-purple-600 mt-1">(Supports .txt, .md, .log, .csv, .pdf)</span>
                </label>
            </div>
            
            <div class="flex flex-col md:flex-row gap-4 mt-4">
                 <button id="start-full-text-review-button" onclick="window.startFullTextReview()"
                    class="hidden flex-1 bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-4 rounded-lg transition duration-200 focus:outline-none focus:ring-4 focus:ring-red-300">
                    Start LLM Full Text Inclusion Review
                </button>
                
                <button id="skip-full-text-button" onclick="window.skipFullTextReview()"
                        class="flex-1 bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-4 rounded-lg transition duration-200 focus:outline-none focus:ring-4 focus:ring-gray-300">
                    Skip Full Text Review & Generate Report (Use Abstracts Only)
                </button>
            </div>
            
            <!-- Document Preview Area -->
            <div id="fileListContainer" class="mt-4 space-y-4">
                <p id="initialMessage" class="text-center text-gray-500 italic p-3">Uploaded or automatically retrieved documents will appear here.</p>
            </div>
        </div>
        
        <!-- Full Text Review Panel (Step 5) -->
        <div id="full-text-review-panel" class="bg-white p-6 rounded-xl shadow-lg mt-8 hidden">
            <h2 class="text-2xl font-semibold text-gray-800 mb-4 border-b pb-2">5. Full Text Review Results</h2>
            <div id="final-review-list" class="scroll-container grid gap-4 grid-cols-1 md:grid-cols-2">
                <p class="text-center text-gray-500 italic">No full text review has been run yet.</p>
            </div>
        </div>

        
        <!-- SLR Report Generation Panel (Step 6) -->
        <div id="report-panel" class="bg-white p-6 rounded-xl shadow-lg mt-8 hidden">
            <h2 class="text-2xl font-semibold text-gray-800 mb-4 border-b pb-2">6. Generate Systematic Review Draft</h2>
            
            <div class="mb-6">
                <label for="drafting-instructions" class="block text-sm font-medium text-gray-700 mb-1">Drafting Instructions (Optional): Tell the AI what kind of report to write.</label>
                <textarea id="drafting-instructions" rows="2" 
                          class="w-full p-3 border border-gray-300 rounded-lg focus:ring-purple-500 focus:border-purple-500 transition duration-150"
                          placeholder="e.g., Summarize key findings in a non-technical way, suitable for a general audience."></textarea>
            </div>
            
            <button id="generate-report-button"
                    class="w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-4 rounded-lg transition duration-200 focus:outline-none focus:ring-4 focus:ring-purple-300">
                Generate Draft SLR
            </button>
            
            <div id="slr-draft-output" class="mt-6 p-4 border border-gray-200 rounded-lg bg-gray-50 max-h-[50vh] overflow-y-auto">
                <!-- LLM generated report will appear here -->
            </div>
        </div>
        
        <!-- SLR Draft Modification Panel (Step 7) -->
        <div id="modification-panel" class="bg-white p-6 rounded-xl shadow-lg mt-8 hidden">
            <h2 class="text-2xl font-semibold text-gray-800 mb-4 border-b pb-2">7. Modify & Refine Draft</h2>
            <div class="mb-6">
                <label for="modification-request" class="block text-sm font-medium text-gray-700 mb-1">Modification Request:</label>
                <textarea id="modification-request" rows="3" 
                          class="w-full p-3 border border-gray-300 rounded-lg focus:ring-orange-500 focus:border-orange-500 transition duration-150"
                          placeholder="e.g., Expand the conclusion to include future research directions, or change the tone to be more critical."></textarea>
            </div>
            <button id="refine-report-button"
                    class="w-full bg-orange-600 hover:bg-orange-700 text-white font-bold py-3 px-4 rounded-lg transition duration-200 focus:outline-none focus:ring-4 focus:ring-orange-300">
                Refine Draft
            </button>
        </div>
        
        <!-- PRISMA Diagram Panel (Step 8) -->
        <div id="prisma-panel" class="bg-white p-6 rounded-xl shadow-lg mt-8 hidden">
            <h2 class="text-2xl font-semibold text-gray-800 mb-4 border-b pb-2">8. Generate PRISMA Flow Diagram</h2>
            
            <button id="generate-prisma-button" onclick="window.generatePrismaDiagram()"
                    class="w-full bg-gray-600 hover:bg-gray-700 text-white font-bold py-3 px-4 rounded-lg transition duration-200 focus:outline-none focus:ring-4 focus:ring-gray-300">
                Generate PRISMA Diagram
            </button>
            
            <div id="prisma-output" class="mt-6 p-4 rounded-lg bg-white overflow-x-auto text-center">
                <!-- SVG diagram will appear here -->
                <p class="text-gray-500 italic">Click the button above to visualize the flow of the review.</p>
            </div>
        </div>

    </div>

    <!-- JavaScript Logic -->
    <script type="module">
        // Global variables for Canvas environment
        const apiKey = "AIzaSyDpqUR_N4g_lHf1zAW53st7iTWpDQlkXsM"; 
        const LLM_MODEL = "gemini-2.5-flash-preview-09-2025";
        const PUBMED_BASE_URL = 'https://eutils.ncbi.nlm.nih.gov/entrez/eutils/';

        // Set up PDF.js Worker
        if (window.pdfjsLib) {
            window.pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        }

        // Application State
        const appState = {
            articles: [], // Array to hold all processed articles
            criteria: {},
            pubmedQuery: '',
            dateLimit: null,
            currentDraft: '',
            uploadedTexts: {} // Stores { filename: content, ... } for both manual and auto-retrieved
        };

        // --- Utility Functions ---

        // HTML for the loading spinner
        const SPINNER_HTML = `<svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-current" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>`;
        
        /**
         * Toggles the loading state of a specific button.
         */
        function setButtonLoading(buttonId, isLoading) {
            const button = document.getElementById(buttonId);
            if (!button) return;

            const originalText = button.getAttribute('data-original-text');
            
            if (isLoading) {
                if (!originalText) button.setAttribute('data-original-text', button.textContent.trim());
                button.disabled = true;
                button.innerHTML = `<span class="flex items-center justify-center text-white">${SPINNER_HTML.replace('text-current', 'text-white')} Working...</span>`;
            } else {
                button.disabled = false;
                button.innerHTML = originalText || 'Start';
                button.removeAttribute('data-original-text');
            }
        }

        /**
         * Generic fetch wrapper with exponential backoff for API robustness.
         */
        async function fetchWithRetry(url, options = {}, retries = 3) {
            for (let i = 0; i < retries; i++) {
                try {
                    const response = await fetch(url, options);
                    if (!response.ok) {
                        if (response.status === 429 && i < retries - 1) { // Rate limit
                            const delay = Math.pow(2, i) * 1000 + Math.random() * 1000;
                            await new Promise(resolve => setTimeout(resolve, delay));
                            continue;
                        }
                        throw new Error(`API Error: ${response.status} ${response.statusText}`);
                    }
                    return response;
                } catch (error) {
                    if (i === retries - 1) {
                        console.error("Fetch failed after all retries:", error);
                        throw error;
                    }
                    const delay = Math.pow(2, i) * 1000 + Math.random() * 1000;
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }

        /**
         * Helper to update the status message box with process feedback.
         */
        function updateStatus(message, type = 'info') {
            const statusEl = document.getElementById('status-message');
            
            const isProcessing = type === 'process' || message.includes('Working');

            statusEl.innerHTML = isProcessing ? `<span class="flex items-center justify-center">${SPINNER_HTML} ${message}</span>` : message;
            
            statusEl.className = 'text-center text-lg font-medium py-4 rounded-xl shadow-md mt-4';
            statusEl.classList.remove('hidden', 'bg-red-100', 'text-red-800', 'bg-green-100', 'text-green-800', 'bg-yellow-100', 'text-yellow-800', 'bg-blue-100', 'text-blue-800', 'flex', 'items-center', 'justify-center');

            if (type === 'error') {
                statusEl.classList.add('bg-red-100', 'text-red-800');
            } else if (type === 'success') {
                statusEl.classList.add('bg-green-100', 'text-green-800');
            } else if (isProcessing) {
                statusEl.classList.add('bg-blue-100', 'text-blue-800');
            } else { // info
                statusEl.classList.add('bg-yellow-100', 'text-yellow-800');
            }
            statusEl.classList.remove('hidden');
        }

        // --- LLM Full Text Review Function ---
        
        /**
         * Step 5.1: Review a single article's full text against criteria.
         */
        async function reviewFullText(article, criteria, fullText) {
            // Truncate full text to prevent exceeding context window (using first 5000 chars)
            const truncatedText = fullText.substring(0, 5000); 

            const systemPrompt = `You are a systematic review expert performing a final full-text screening. Analyze the provided FULL TEXT against the strict Inclusion/Exclusion criteria. Base your decision ONLY on the full text and criteria. Your output MUST be a single JSON object.`;

            const userQuery = `
                Article PMID: ${article.PMID}
                Research Question: ${document.getElementById('research-question').value.trim()}
                
                CRITERIA: 
                Inclusion: ${criteria.Inclusion}
                Exclusion: ${criteria.Exclusion}

                FULL TEXT (Excerpt):
                ---
                ${truncatedText}
                ---

                Original Abstract Decision: ${article.Decision} (${article.Reasoning})
                
                Based on the FULL TEXT, output the JSON object with the following properties:
                1. FinalDecision: 'FINAL_INCLUDE' or 'FINAL_EXCLUDE'.
                2. FinalReasoning: A concise 2-3 sentence justification for your FinalDecision based *only* on the full text.
            `;

            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                systemInstruction: { parts: [{ text: systemPrompt }] },
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: "OBJECT",
                        properties: {
                            "FinalDecision": { "type": "STRING", "enum": ["FINAL_INCLUDE", "FINAL_EXCLUDE"] },
                            "FinalReasoning": { "type": "STRING" }
                        }
                    }
                }
            };
            
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${LLM_MODEL}:generateContent?key=${apiKey}`;

            try {
                const response = await fetchWithRetry(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const result = await response.json();
                const jsonText = result.candidates?.[0]?.content?.parts?.[0]?.text;
                
                if (jsonText) {
                    const llmResult = JSON.parse(jsonText);
                    return {
                        FinalDecision: llmResult.FinalDecision,
                        FinalReasoning: llmResult.FinalReasoning,
                    };
                } else {
                    throw new Error("LLM returned an empty or unparsable response.");
                }
            } catch (error) {
                console.error("LLM full text review error for PMID", article.PMID, error);
                return {
                    FinalDecision: 'ERROR',
                    FinalReasoning: 'LLM failed to process full text.',
                };
            }
        }
        
        /**
         * Step 5: Initiates the Full Text Review process.
         */
        window.startFullTextReview = async () => {
            setButtonLoading('start-full-text-review-button', true);
            document.getElementById('full-text-review-panel').classList.remove('hidden');
            document.getElementById('final-review-list').innerHTML = `<p class="text-center text-gray-500 italic flex items-center justify-center">${SPINNER_HTML} Preparing articles for review...</p>`;
            document.getElementById('report-panel').classList.add('hidden');
            document.getElementById('modification-panel').classList.add('hidden');
            document.getElementById('prisma-panel').classList.add('hidden');

            // 1. Identify Included Articles from Step 3
            const articlesToReview = appState.articles.filter(a => (a.Decision === 'INCLUDE' && !a.Override) || a.Override);

            if (articlesToReview.length === 0) {
                 updateStatus('No articles were included in the abstract phase. Cannot proceed with full text review.', 'info');
                 setButtonLoading('start-full-text-review-button', false);
                 return;
            }
            if (Object.keys(appState.uploadedTexts).length === 0) {
                 updateStatus('Please upload full text documents in Step 4 before starting the review, or wait for automatic retrieval to finish.', 'error');
                 setButtonLoading('start-full-text-review-button', false);
                 return;
            }

            // 2. Pair Articles with Uploaded Texts and create the review queue
            const reviewQueue = articlesToReview.map(article => {
                // Priority 1: Check if the article was auto-retrieved (FullTextFileName is set)
                if (article.FullTextFileName && appState.uploadedTexts[article.FullTextFileName]) {
                    return {
                        article,
                        fullText: appState.uploadedTexts[article.FullTextFileName],
                        fileName: article.FullTextFileName
                    };
                }

                // Priority 2: Check for a manually uploaded file matching the PMID
                const matchingFileName = Object.keys(appState.uploadedTexts).find(filename => 
                    filename.includes(article.PMID)
                );
                
                if (matchingFileName) {
                    return {
                        article,
                        fullText: appState.uploadedTexts[matchingFileName],
                        fileName: matchingFileName
                    };
                }
                return null;
            }).filter(item => item !== null);
            
            if (reviewQueue.length === 0) {
                updateStatus('No full texts found for included articles, either automatically or manually uploaded. Ensure PMIDs are in the filenames of manual uploads.', 'error');
                document.getElementById('final-review-list').innerHTML = `<p class="text-center text-red-500 font-medium">No full texts found for included articles. Review your uploads.</p>`;
                setButtonLoading('start-full-text-review-button', false);
                return;
            }


            // 3. Run LLM review for the queue
            updateStatus(`**Starting Full Text Review for ${reviewQueue.length} articles.** This will analyze the documents against the criteria.`, 'process');
            
            const reviewPromises = reviewQueue.map(async (queueItem) => {
                const llmResult = await reviewFullText(queueItem.article, appState.criteria, queueItem.fullText);
                
                // Update the original article in appState
                const index = appState.articles.findIndex(a => a.PMID === queueItem.article.PMID);
                if (index !== -1) {
                    appState.articles[index].FinalDecision = llmResult.FinalDecision;
                    appState.articles[index].FinalReasoning = llmResult.FinalReasoning;
                    // If it was manual upload, set the filename for consistency
                    if (!appState.articles[index].FullTextFileName) {
                        appState.articles[index].FullTextFileName = queueItem.fileName;
                    }
                }
            });

            // Wait for all LLM calls to complete
            await Promise.all(reviewPromises);
            
            // 4. Render Final Results and show next panels
            renderFinalReviewResults();
            updateStatus(`Full Text Review complete! ${reviewQueue.length} articles analyzed.`, 'success');
            setButtonLoading('start-full-text-review-button', false);
            
            // Show Step 6, 7 and 8 now
            document.getElementById('report-panel').classList.remove('hidden');
            document.getElementById('prisma-panel').classList.remove('hidden');
        }

        /**
         * Bypasses the full text review and proceeds to report generation using abstract data.
         */
        window.skipFullTextReview = () => {
            const includedCount = appState.articles.filter(a => (a.Decision === 'INCLUDE' && !a.Override) || a.Override).length;
            
            if (includedCount === 0) {
                updateStatus('No articles included from abstract screening. Cannot proceed.', 'error');
                return;
            }
            
            document.getElementById('report-panel').classList.remove('hidden');
            document.getElementById('prisma-panel').classList.remove('hidden');
            
            // Hide Step 5 panel if it was open (to avoid confusion)
            document.getElementById('full-text-review-panel').classList.add('hidden');
            
            updateStatus('Skipped Full Text Review. Proceeding with abstract data for report generation.', 'info');
            
            // Scroll to report panel
            setTimeout(() => {
                document.getElementById('report-panel').scrollIntoView({ behavior: 'smooth' });
            }, 100);
        };


        // --- PMC Retrieval Functions ---

        /**
         * Fetches the full text content from PMC using the PMCID.
         */
        async function fetchFullTextFromPMC(pmcid) {
            // Using retmode=text and rettype=full should return a clean text dump.
            const url = `${PUBMED_BASE_URL}efetch.fcgi?db=pmc&id=${pmcid}&retmode=text&rettype=full`;

            try {
                const response = await fetchWithRetry(url);
                const fullText = await response.text();
                
                // Check for common error messages in the returned text
                if (fullText.includes("cannot be found") || fullText.includes("error")) {
                    console.warn(`PMC Retrieval failed for ${pmcid}: Error in returned text.`);
                    return null;
                }
                
                // Content will often start with the title and abstract, which is fine.
                return fullText;

            } catch (error) {
                console.error(`Error fetching full text for PMCID ${pmcid}:`, error);
                return null;
            }
        }
        
        /**
         * Attempts to automatically retrieve full text for all included articles with a PMCID.
         */
        async function attemptFullTextRetrieval() {
            // 1. Identify Included Articles with a PMCID
            const includedArticles = appState.articles.filter(a => 
                ((a.Decision === 'INCLUDE' && !a.Override) || a.Override) && a.PMCID && !a.FullTextFileName
            );
            
            if (includedArticles.length === 0) {
                document.getElementById('retrieval-status-message').innerHTML = `No open-access articles (with PMC IDs) were identified among the articles included by abstract.`;
                document.getElementById('retrieval-status-message').classList.remove('hidden', 'bg-yellow-50', 'text-yellow-800');
                document.getElementById('retrieval-status-message').classList.add('bg-blue-50', 'text-blue-800');
                return;
            }
            
            document.getElementById('retrieval-status-message').innerHTML = `<span class="flex items-center justify-center">${SPINNER_HTML} Attempting automatic full text retrieval for **${includedArticles.length}** articles via PMC...</span>`;
            document.getElementById('retrieval-status-message').classList.remove('hidden', 'bg-blue-50', 'text-blue-800');
            document.getElementById('retrieval-status-message').classList.add('bg-yellow-50', 'text-yellow-800');


            const retrievalPromises = includedArticles.map(async (article) => {
                const fullText = await fetchFullTextFromPMC(article.PMCID);
                if (fullText) {
                    // Store content in uploadedTexts using a standard filename format
                    const fileName = `AUTO_PMC_${article.PMCID}_(PMID_${article.PMID}).txt`;
                    appState.uploadedTexts[fileName] = fullText;
                    
                    // Mark article as auto-retrieved in the main state
                    const index = appState.articles.findIndex(a => a.PMID === article.PMID);
                    if (index !== -1) {
                        appState.articles[index].FullTextFileName = fileName;
                    }
                    return true;
                }
                return false;
            });

            const results = await Promise.all(retrievalPromises);
            const successCount = results.filter(r => r).length;
            
            if (successCount === 0 && includedArticles.length > 0) {
                document.getElementById('retrieval-status-message').innerHTML = `**PMC retrieval finished:** No full text articles could be automatically retrieved. Please manually upload files or use the "Skip Full Text Review" button to proceed with abstracts only.`;
                document.getElementById('retrieval-status-message').classList.remove('bg-yellow-50', 'text-yellow-800');
                document.getElementById('retrieval-status-message').classList.add('bg-red-50', 'text-red-800');
            } else {
                document.getElementById('retrieval-status-message').innerHTML = `**PMC retrieval finished:** Successfully downloaded full text for **${successCount}** articles. Please manually upload the remaining paywalled articles.`;
                document.getElementById('retrieval-status-message').classList.remove('bg-yellow-50', 'text-yellow-800');
                document.getElementById('retrieval-status-message').classList.add('bg-green-50', 'text-green-800');
            }

            renderFullTextUploadStatus(); // Update the file list UI
        }


        // --- PubMed API Functions ---

        async function generateCriteriaAndQuery(researchQuestion) {
            setButtonLoading('generate-button', true);
            updateStatus('Analyzing research question and drafting PICO & criteria...', 'process');

            const systemPrompt = `You are a systematic review methodologist. Analyze the research question provided by the user. You must output a structured PICO analysis, strict Inclusion and Exclusion criteria, and generate a robust, high-sensitivity search query suitable for a Systematic Literature Review (SLR). Your output MUST be a single JSON object.`;

            const userQuery = `
                Research Question: ${researchQuestion}

                Output the JSON object with the following properties:
                1. PICO: An object containing "Population", "Intervention", "Comparison", "Outcome" as strings.
                2. Inclusion: Strict criteria for including an article, based on PICO elements if applicable.
                3. Exclusion: Strict criteria for excluding an article (e.g., study type, language, publication type).
                4. SuggestedPubmedQuery: A comprehensive, SLR-grade search query string suitable for the PubMed ESearch API.
                   - MUST use PubMed field tags (e.g., [MeSH Terms], [Title/Abstract] or [tiab]).
                   - MUST include both controlled vocabulary (MeSH) and free-text keywords for each PICO concept.
                   - MUST use truncation (*) for keyword variations.
                   - MUST use proper Boolean logic: (Synonym1 OR Synonym2 OR MeSH1) AND (Synonym3 OR Synonym4)...
                   - Prioritize sensitivity (finding all relevant studies) over precision.
            `;

            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                systemInstruction: { parts: [{ text: systemPrompt }] },
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: "OBJECT",
                        properties: {
                            "PICO": {
                                "type": "OBJECT",
                                "properties": {
                                    "Population": { "type": "STRING" },
                                    "Intervention": { "type": "STRING" },
                                    "Comparison": { "type": "STRING" },
                                    "Outcome": { "type": "STRING" }
                                }
                            },
                            "Inclusion": { "type": "STRING" },
                            "Exclusion": { "type": "STRING" },
                            "SuggestedPubmedQuery": { "type": "STRING" }
                        }
                    }
                }
            };
            
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${LLM_MODEL}:generateContent?key=${apiKey}`;

            try {
                const response = await fetchWithRetry(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const result = await response.json();
                const jsonText = result.candidates?.[0]?.content?.parts?.[0]?.text;
                
                if (jsonText) {
                    const llmResult = JSON.parse(jsonText);
                    setButtonLoading('generate-button', false);
                    updateStatus('Criteria and PICO analysis generated. Please review them below.', 'success');
                    return llmResult;
                } else {
                    throw new Error("LLM returned an empty or unparsable response.");
                }
            } catch (error) {
                console.error("LLM criteria generation error:", error);
                setButtonLoading('generate-button', false);
                updateStatus(`Generation failed: ${error.message}. Please try again.`, 'error');
                return null;
            }
        }
        
        async function fetchPubmedUids(query, dateLimit) {
            updateStatus(`Searching PubMed for "${query}"...`, 'process');
            
            let url = `${PUBMED_BASE_URL}esearch.fcgi?db=pubmed&term=${encodeURIComponent(query)}&retmax=100&sort=relevance&retmode=json`;
            
            if (dateLimit && !isNaN(parseInt(dateLimit))) {
                const currentYear = new Date().getFullYear();
                const startYear = parseInt(dateLimit);
                url += `&mindate=${startYear}&maxdate=${currentYear}&datetype=pdat`;
                
                updateStatus(`Searching PubMed for "${query}" since ${startYear}...`, 'process');
            }

            const response = await fetchWithRetry(url);
            const data = await response.json();
            
            if (data.esearchresult && data.esearchresult.idlist) {
                const uids = data.esearchresult.idlist;
                updateStatus(`Found ${uids.length} articles (limited to top 100 by relevance). Retrieving abstracts...`, 'process');
                return uids;
            } else {
                const errorMessage = data.esearchresult?.error || 'PubMed search returned an unexpected result.';
                throw new Error(errorMessage);
            }
        }

        async function fetchAbstracts(uids) {
            if (uids.length === 0) return [];
            
            const chunkSize = 500;
            const allArticles = [];

            for (let i = 0; i < uids.length; i += chunkSize) {
                const chunk = uids.slice(i, i + chunkSize);
                const uidString = chunk.join(',');
                
                updateStatus(`Retrieving abstracts for chunk ${Math.floor(i/chunkSize) + 1} of ${Math.ceil(uids.length / chunkSize)}...`, 'process');

                const url = `${PUBMED_BASE_URL}efetch.fcgi?db=pubmed&id=${uidString}&retmode=xml&rettype=abstract`;

                const response = await fetchWithRetry(url);
                const text = await response.text();

                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(text, "application/xml");

                xmlDoc.querySelectorAll('PubmedArticle').forEach(articleEl => {
                    const pmidEl = articleEl.querySelector('PMID');
                    const titleEl = articleEl.querySelector('ArticleTitle');
                    const abstractEl = articleEl.querySelector('AbstractText');
                    
                    let pmcid = null;
                    // Try to find the PMC ID for auto-retrieval later
                    articleEl.querySelectorAll('ArticleId').forEach(id => {
                        if (id.getAttribute('IdType') === 'pmc') {
                            pmcid = id.textContent;
                        }
                    });

                    if (pmidEl && titleEl) {
                        allArticles.push({
                            PMID: pmidEl.textContent,
                            Title: titleEl.textContent || 'No Title Found',
                            Abstract: abstractEl ? abstractEl.textContent : 'No Abstract Available.',
                            PMCID: pmcid, // Store PMC ID for retrieval
                            Decision: 'PENDING',
                            Category: 'PENDING',
                            Reasoning: 'Awaiting LLM review.',
                            Override: false, // Human override flag
                            FullTextFileName: null, // To be set if auto-retrieved
                        });
                    }
                });
            }
            return allArticles;
        }

        async function screenArticle(article, criteria) {
            const systemPrompt = `You are a systematic review expert. Analyze the provided article's Title and Abstract against the following strict Inclusion/Exclusion criteria. Your output MUST be a single JSON object.`;

            const userQuery = `
                Article PMID: ${article.PMID}
                Title: ${article.Title}
                Abstract: ${article.Abstract}
                
                CRITERIA: 
                Inclusion: ${criteria.Inclusion}
                Exclusion: ${criteria.Exclusion}

                Output the JSON object with the following properties:
                1. Decision: 'INCLUDE' or 'EXCLUDE'.
                2. Category: A single category label (e.g., 'Clinical Application', 'Medical Education', 'Ethical Review', 'Other').
                3. Reasoning: A concise 1-2 sentence justification for your Decision based *only* on the criteria and abstract.
            `;

            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                systemInstruction: { parts: [{ text: systemPrompt }] },
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: "OBJECT",
                        properties: {
                            "Decision": { "type": "STRING", "enum": ["INCLUDE", "EXCLUDE"] },
                            "Category": { "type": "STRING" },
                            "Reasoning": { "type": "STRING" }
                        }
                    }
                }
            };
            
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${LLM_MODEL}:generateContent?key=${apiKey}`;

            try {
                const response = await fetchWithRetry(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const result = await response.json();
                const jsonText = result.candidates?.[0]?.content?.parts?.[0]?.text;
                
                if (jsonText) {
                    const llmResult = JSON.parse(jsonText);
                    return {
                        Decision: llmResult.Decision,
                        Category: llmResult.Category,
                        Reasoning: llmResult.Reasoning,
                        Override: false
                    };
                } else {
                    throw new Error("LLM returned an empty or unparsable response.");
                }
            } catch (error) {
                console.error("LLM screening error for PMID", article.PMID, error);
                return {
                    Decision: 'ERROR',
                    Category: 'ERROR',
                    Reasoning: 'LLM failed to process article.',
                    Override: false
                };
            }
        }
        
        /**
         * Step 6: Generates a draft Systematic Review Report based on included articles.
         */
        async function generateSLRReport() {
            setButtonLoading('generate-report-button', true);
            const outputEl = document.getElementById('slr-draft-output');
            outputEl.innerHTML = 'Preparing included data...';
            document.getElementById('modification-panel').classList.add('hidden'); 
            appState.currentDraft = ''; 

            // Filter logic: Only include articles that were successfully included in the final screening.
            const articlesToConsider = appState.articles.filter(a => {
                const isFinal = a.FinalDecision && a.FinalDecision === 'FINAL_INCLUDE';
                const isAbstractOnly = !a.FinalDecision && ((a.Decision === 'INCLUDE' && !a.Override) || a.Override);
                return isFinal || isAbstractOnly;
            });
            
            if (articlesToConsider.length === 0) {
                outputEl.innerHTML = 'No articles were included in the final screening list. Cannot generate a report.';
                setButtonLoading('generate-report-button', false);
                return;
            }

            const articleDataSummary = articlesToConsider.map(a => `
PMID: ${a.PMID}
Title: ${a.Title}
Abstract (Excerpt): ${a.Abstract.substring(0, 300)}...
LLM Category: ${a.Category}
Full Text Status: ${a.FullTextFileName ? 'Available' : 'NOT Available'}
`).join('\n---\n');

            const researchQuestion = document.getElementById('research-question').value.trim();
            const criteriaText = document.getElementById('inclusion-criteria').value.trim();
            
            // --- UPDATED SYSTEM PROMPT FOR CITATIONS ---
            const systemPrompt = `You are a professional systematic review writer. Your task is to synthesize the provided articles into a concise, well-structured, academic draft of a Systematic Review Report. Structure the output clearly using Markdown headings (# Introduction, ## Methods Summary, ## Results Synthesis, and ## Conclusion). The tone should be formal and objective. Critically, you MUST include **inline citations** in the text using the format **(PMID: [PMID number])** for every specific finding or claim. Finally, you MUST append a section titled **## References** at the very end, listing the full citation (Title and PMID) for every article used in the synthesis. Do not include any introductory text before the Markdown document.`;

            let userQuery = `
Generate a Systematic Review Draft based on the following information:

1. Primary Research Question: ${researchQuestion}
2. Total Included Articles: ${articlesToConsider.length}
3. Initial Search Criteria Summary (for Methods section): ${criteriaText}
4. Synthesize the findings and categories from these article abstracts. Use the PMID provided for each article to create your inline citations:

${articleDataSummary}
`;
            
            const draftingInstructions = document.getElementById('drafting-instructions').value.trim();
            if (draftingInstructions) {
                userQuery += `\n\n5. USER DRAFTING INSTRUCTIONS: ${draftingInstructions}`;
            }


            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                systemInstruction: { parts: [{ text: systemPrompt }] },
            };
            
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${LLM_MODEL}:generateContent?key=${apiKey}`;

            try {
                updateStatus('Generating SLR Draft (Step 6)... This may take a moment.', 'process');
                const response = await fetchWithRetry(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const result = await response.json();
                const reportText = result.candidates?.[0]?.content?.parts?.[0]?.text;
                
                if (reportText) {
                    appState.currentDraft = reportText;
                    
                    let htmlReport = reportText
                        .replace(/^#{1}\s*(.*)$/gm, '<h1>$1</h1>')
                        .replace(/^#{2}\s*(.*)$/gm, '<h2>$1</h2>')
                        .replace(/^#{3}\s*(.*)$/gm, '<h3>$1</h3>')
                        .replace(/\n/g, '<br>');

                    outputEl.innerHTML = htmlReport;
                    document.getElementById('modification-panel').classList.remove('hidden'); 
                    document.getElementById('prisma-panel').classList.remove('hidden');
                    updateStatus('Systematic Review Draft successfully generated with citations. Review it and ask for modifications below.', 'success');
                } else {
                    outputEl.innerHTML = 'LLM failed to generate a report. Check logs for details.';
                    throw new Error("LLM returned an empty report.");
                }
            } catch (error) {
                console.error("SLR report generation error:", error);
                updateStatus(`Report generation failed: ${error.message}`, 'error');
            } finally {
                setButtonLoading('generate-report-button', false);
            }
        }
        
        /**
         * Step 7: Modifies the existing SLR Draft based on user request.
         */
        async function refineSLRReport() {
            setButtonLoading('refine-report-button', true);
            const outputEl = document.getElementById('slr-draft-output');
            const modificationRequest = document.getElementById('modification-request').value.trim();

            if (!appState.currentDraft) {
                outputEl.innerHTML = 'Error: No draft to modify. Please generate the initial draft first.';
                setButtonLoading('refine-report-button', false);
                return;
            }
            if (!modificationRequest) {
                outputEl.innerHTML = 'Please enter a modification request before clicking "Refine Draft."';
                setButtonLoading('refine-report-button', false);
                return;
            }

            // --- UPDATED SYSTEM PROMPT FOR CITATION REFINEMENT ---
            const systemPrompt = `You are a professional editor and systematic review writer. Your task is to take the provided DRAFT REPORT and revise it entirely based on the MODIFICATION REQUEST. Output the complete, revised document using Markdown headings. **Crucially, you must maintain and update the inline citations (PMID: [PMID number]) and the final ## References section** based on the content of the revised draft. Do not include any introductory text before the revised Markdown document.`;

            const userQuery = `
DRAFT REPORT TO REVISE:
---
${appState.currentDraft}
---

MODIFICATION REQUEST:
${modificationRequest}

Provide the full, revised report.
`;
            
            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                systemInstruction: { parts: [{ text: systemPrompt }] },
            };
            
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${LLM_MODEL}:generateContent?key=${apiKey}`;

            try {
                updateStatus('Applying modifications and generating new draft...', 'process');
                const response = await fetchWithRetry(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const result = await response.json();
                const revisedText = result.candidates?.[0]?.content?.parts?.[0]?.text;
                
                if (revisedText) {
                    appState.currentDraft = revisedText; 
                    
                    let htmlReport = revisedText
                        .replace(/^#{1}\s*(.*)$/gm, '<h1>$1</h1>')
                        .replace(/^#{2}\s*(.*)$/gm, '<h2>$1</h2>')
                        .replace(/^#{3}\s*(.*)$/gm, '<h3>$1</h3>')
                        .replace(/\n/g, '<br>');

                    outputEl.innerHTML = htmlReport;
                    updateStatus('Draft successfully refined. Feel free to ask for more modifications.', 'success');
                } else {
                    outputEl.innerHTML = 'LLM failed to refine the report. Check logs for details.';
                    throw new Error("LLM returned an empty revised document.");
                }
            } catch (error) {
                console.error("SLR refinement error:", error);
                updateStatus(`Draft refinement failed: ${error.message}`, 'error');
            } finally {
                setButtonLoading('refine-report-button', false);
            }
        }
        
        /**
         * Step 8: Generates the PRISMA diagram SVG.
         */
        window.generatePrismaDiagram = () => {
            const outputEl = document.getElementById('prisma-output');
            outputEl.innerHTML = `<p class="text-gray-500 italic flex items-center justify-center">${SPINNER_HTML} Calculating metrics...</p>`;
            
            const totalFound = appState.articles.length;
            
            // Abstract Screening Metrics
            const includedForFullText = appState.articles.filter(a => (a.Decision === 'INCLUDE' && !a.Override) || a.Override).length;
            const excludedByAbstract = appState.articles.filter(a => a.Decision === 'EXCLUDE' && !a.Override).length;

            // Full Text Review Metrics
            const reviewedFullText = appState.articles.filter(a => a.FinalDecision).length;
            const includedInSynthesis = appState.articles.filter(a => a.FinalDecision === 'FINAL_INCLUDE').length;
            const excludedByFullText = appState.articles.filter(a => a.FinalDecision === 'FINAL_EXCLUDE').length;
            
            // Derived Metrics
            const notReviewedFullText = includedForFullText - reviewedFullText;
            
            // If Full Text Review was skipped (reviewed = 0, includedForFullText > 0), synthesis count implies using Abstract inclusions
            let synthesisTotal;
            if (reviewedFullText === 0 && includedForFullText > 0) {
                 synthesisTotal = includedForFullText;
            } else {
                 synthesisTotal = includedInSynthesis;
            }

            // --- Layout Configuration ---
            const boxWidth = 260; 
            const boxHeight = 64;
            const xCenter = 400; 
            
            // Explicit Y coordinates to prevent overlaps
            const yPhase1 = 30;   // Identification
            const yPhase2 = 150;  // Screening
            const yPhase3 = 270;  // Eligibility
            const yExclusionLayer = 390; // New layer for full text exclusions
            const yPhase4 = 520;  // Included
            
            const drawBox = (x, y, text1, text2, color) => `
                <rect x="${x - boxWidth / 2}" y="${y}" width="${boxWidth}" height="${boxHeight}" rx="8" ry="8" fill="#FFFFFF" stroke="${color}" stroke-width="2"/>
                <text x="${x}" y="${y + 24}" font-weight="bold" fill="#333" font-size="14" text-anchor="middle">${text1}</text>
                <text x="${x}" y="${y + 44}" fill="#555" font-size="12" text-anchor="middle">${text2}</text>
            `;

            const drawArrow = (x1, y1, x2, y2) => `
                <line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="#6b7280" stroke-width="2" marker-end="url(#arrowhead)"/>
            `;
            
            const svgContent = `
                <svg width="100%" height="650" viewBox="0 0 800 650" xmlns="http://www.w3.org/2000/svg" style="font-family: 'Inter', sans-serif;">
                    <defs>
                        <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="0" refY="3.5" orient="auto">
                            <polygon points="0 0, 10 3.5, 0 7" fill="#6b7280" />
                        </marker>
                    </defs>

                    <!-- Phase 1: Identification -->
                    ${drawBox(xCenter, yPhase1, 'Identification', `Records identified (${totalFound})`, '#2563EB')}
                    ${drawArrow(xCenter, yPhase1 + boxHeight, xCenter, yPhase2)}
                    
                    <!-- Phase 2: Screening -->
                    ${drawBox(xCenter, yPhase2, 'Screening', `Records screened (${totalFound})`, '#2563EB')}
                    
                    <!-- Screening Exclusion (Right Side) -->
                    <line x1="${xCenter + boxWidth/2}" y1="${yPhase2 + boxHeight/2}" x2="${xCenter + boxWidth/2 + 30}" y2="${yPhase2 + boxHeight/2}" stroke="#EF4444" stroke-width="2" marker-end="url(#arrowhead)"/>
                    <rect x="${xCenter + boxWidth/2 + 40}" y="${yPhase2 + 12}" width="160" height="40" rx="6" ry="6" fill="#FEE2E2" stroke="#EF4444" stroke-width="2"/>
                    <text x="${xCenter + boxWidth/2 + 120}" y="${yPhase2 + 36}" fill="#EF4444" font-size="11" text-anchor="middle">Excluded (${excludedByAbstract})</text>

                    ${drawArrow(xCenter, yPhase2 + boxHeight, xCenter, yPhase3)}

                    <!-- Phase 3: Eligibility -->
                    ${drawBox(xCenter, yPhase3, 'Eligibility', `Full-text assessed (${includedForFullText})`, '#9333EA')}
                    
                    <!-- Branching Logic for Full Text Exclusions -->
                    <!-- Vertical line down from Eligibility box -->
                    <line x1="${xCenter}" y1="${yPhase3 + boxHeight}" x2="${xCenter}" y2="${yExclusionLayer - 25}" stroke="#6b7280" stroke-width="2"/>
                    
                    <!-- Horizontal bar for branching -->
                    <line x1="${xCenter - 180}" y1="${yExclusionLayer - 25}" x2="${xCenter + 180}" y2="${yExclusionLayer - 25}" stroke="#6b7280" stroke-width="2"/>
                    
                    <!-- Left Branch: Full Text Not Retrieved -->
                    <line x1="${xCenter - 180}" y1="${yExclusionLayer - 25}" x2="${xCenter - 180}" y2="${yExclusionLayer}" stroke="#EF4444" stroke-width="2" marker-end="url(#arrowhead)"/>
                    <rect x="${xCenter - 270}" y="${yExclusionLayer}" width="180" height="55" rx="6" ry="6" fill="#FEE2E2" stroke="#EF4444" stroke-width="2"/>
                    <text x="${xCenter - 180}" y="${yExclusionLayer + 22}" fill="#EF4444" font-size="11" text-anchor="middle" font-weight="bold">Not Retrieved</text>
                    <text x="${xCenter - 180}" y="${yExclusionLayer + 40}" fill="#EF4444" font-size="11" text-anchor="middle">(${notReviewedFullText})</text>

                    <!-- Right Branch: Excluded by Review -->
                    <line x1="${xCenter + 180}" y1="${yExclusionLayer - 25}" x2="${xCenter + 180}" y2="${yExclusionLayer}" stroke="#EF4444" stroke-width="2" marker-end="url(#arrowhead)"/>
                    <rect x="${xCenter + 90}" y="${yExclusionLayer}" width="180" height="55" rx="6" ry="6" fill="#FEE2E2" stroke="#EF4444" stroke-width="2"/>
                    <text x="${xCenter + 180}" y="${yExclusionLayer + 22}" fill="#EF4444" font-size="11" text-anchor="middle" font-weight="bold">Excluded by Review</text>
                    <text x="${xCenter + 180}" y="${yExclusionLayer + 40}" fill="#EF4444" font-size="11" text-anchor="middle">(${excludedByFullText})</text>

                    <!-- Center Flow to Included (From split point) -->
                     <line x1="${xCenter}" y1="${yExclusionLayer - 25}" x2="${xCenter}" y2="${yPhase4}" stroke="#6b7280" stroke-width="2" marker-end="url(#arrowhead)"/>
                    
                    <!-- Phase 4: Included -->
                    ${drawBox(xCenter, yPhase4, 'Included', `Included in Review (${synthesisTotal})`, '#059669')}
                    
                </svg>
            `;
            
            outputEl.innerHTML = svgContent;
            updateStatus('PRISMA Diagram generated successfully.', 'success');
        };

        /**
         * Renders a single article card for Step 3 (Abstract Screening).
         */
        function renderArticleCard(article) {
            let statusClasses = '';
            let statusText = article.Decision;
            let actionButton = '';

            const isIncluded = (article.Decision === 'INCLUDE' && !article.Override) || article.Override;

            if (isIncluded) {
                statusClasses = 'bg-green-100 text-green-800 border-green-300';
                if (article.Override) {
                    statusText = 'INCLUDED (Human Override)';
                    statusClasses = 'bg-yellow-100 text-yellow-800 border-yellow-300';
                } else {
                    statusText = 'INCLUDED (AI)';
                }
            } else if (article.Decision === 'EXCLUDE' || article.Decision === 'ERROR') {
                statusClasses = 'bg-red-100 text-red-800 border-red-300';
                statusText = article.Decision === 'EXCLUDE' ? 'EXCLUDED (AI)' : 'ERROR';
                
                if (article.Decision === 'EXCLUDE') {
                     actionButton = `
                        <button onclick="window.handleOverride('${article.PMID}')" 
                                class="mt-4 w-full bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg transition duration-200">
                            Override & Include
                        </button>`;
                }
            }

            const pmcBadge = article.PMCID ? 
                `<span class="inline-flex items-center rounded-full bg-purple-100 px-2 py-0.5 text-xs font-medium text-purple-800">PMC ID: ${article.PMCID.replace('PMC', '')}</span>` 
                : '';

            return `
                <div id="card-${article.PMID}" class="article-card p-4 rounded-xl border-t-4 ${statusClasses}">
                    <a href="https://pubmed.ncbi.nlm.nih.gov/${article.PMID}/" target="_blank" class="text-lg font-bold text-blue-800 hover:underline block">${article.Title}</a>
                    <div class="flex flex-wrap gap-2 items-center mb-2">
                        <p class="text-xs text-gray-500">PMID: ${article.PMID} | Category: <span class="font-semibold">${article.Category}</span></p>
                        ${pmcBadge}
                    </div>
                    
                    <div class="my-2 p-2 rounded-lg text-sm font-medium ${statusClasses} border">
                        Status: ${statusText}
                    </div>

                    <p class="text-sm text-gray-700 font-semibold mt-3">AI Reasoning (Abstract):</p>
                    <p class="text-sm text-gray-600 italic mb-3">"${article.Reasoning}"</p>

                    <details class="text-xs text-gray-500 cursor-pointer mt-2">
                        <summary>View Abstract</summary>
                        <p class="mt-1 p-2 bg-gray-50 rounded">${article.Abstract}</p>
                    </details>
                    
                    ${actionButton}
                </div>
            `;
        }

        /**
         * Renders a single article card for Step 5 (Full Text Review).
         */
        function renderFinalReviewCard(article) {
            let statusClasses = '';
            let statusText = article.FinalDecision;
            
            const isFinalIncluded = article.FinalDecision === 'FINAL_INCLUDE';

            if (isFinalIncluded) {
                statusClasses = 'bg-purple-100 text-purple-800 border-purple-300';
                statusText = 'FINAL INCLUDED (FULL TEXT)';
            } else if (article.FinalDecision === 'FINAL_EXCLUDE' || article.FinalDecision === 'ERROR') {
                statusClasses = 'bg-red-100 text-red-800 border-red-300';
                statusText = article.FinalDecision === 'FINAL_EXCLUDE' ? 'FINAL EXCLUDED (FULL TEXT)' : 'ERROR';
            } else {
                return ''; // Should not happen if Step 5 is run successfully
            }

            return `
                <div id="final-card-${article.PMID}" class="article-card p-4 rounded-xl border-t-4 ${statusClasses}">
                    <a href="https://pubmed.ncbi.nlm.nih.gov/${article.PMID}/" target="_blank" class="text-lg font-bold text-blue-800 hover:underline block">${article.Title}</a>
                    <p class="text-xs text-gray-500 mb-2">
                        PMID: ${article.PMID} | Source: <span class="font-semibold text-purple-600">${article.FullTextFileName.startsWith('AUTO_') ? 'Auto-Retrieved (PMC)' : 'Manually Uploaded'}</span>
                    </p>
                    
                    <div class="my-2 p-2 rounded-lg text-sm font-medium ${statusClasses} border">
                        Status: ${statusText}
                    </div>

                    <p class="text-sm text-gray-700 font-semibold mt-3">Final LLM Reasoning:</p>
                    <p class="text-sm text-gray-600 italic mb-3">"${article.FinalReasoning}"</p>
                </div>
            `;
        }

        /**
         * Renders the entire results view for Step 3.
         */
        function renderResults() {
            const includedListEl = document.getElementById('included-list');
            const excludedListEl = document.getElementById('excluded-list');
            const includedCountEl = document.getElementById('included-count');
            const excludedCountEl = document.getElementById('excluded-count');

            includedListEl.innerHTML = '';
            excludedListEl.innerHTML = '';
            
            const included = appState.articles.filter(a => (a.Decision === 'INCLUDE' && !a.Override) || a.Override);
            const excluded = appState.articles.filter(a => a.Decision === 'EXCLUDE' && !a.Override);

            included.forEach(article => {
                includedListEl.innerHTML += renderArticleCard(article);
            });

            excluded.forEach(article => {
                excludedListEl.innerHTML += renderArticleCard(article);
            });
            
            includedCountEl.textContent = included.length;
            excludedCountEl.textContent = excluded.length;
            document.getElementById('results-panel').classList.remove('hidden');
            
            // Show Step 4 (Upload)
            if (included.length > 0) {
                document.getElementById('upload-panel').classList.remove('hidden');
                // Run automatic full text retrieval immediately
                attemptFullTextRetrieval();
            } else {
                document.getElementById('upload-panel').classList.add('hidden');
                document.getElementById('full-text-review-panel').classList.add('hidden');
                document.getElementById('report-panel').classList.add('hidden');
                document.getElementById('modification-panel').classList.add('hidden');
                document.getElementById('prisma-panel').classList.add('hidden');
            }
        }
        
        /**
         * Renders the entire results view for Step 5.
         */
        function renderFinalReviewResults() {
            const finalReviewListEl = document.getElementById('final-review-list');
            finalReviewListEl.innerHTML = '';

            const reviewedArticles = appState.articles.filter(a => a.FinalDecision);

            if (reviewedArticles.length === 0) {
                finalReviewListEl.innerHTML = `<p class="text-center text-gray-500 italic">No articles were successfully reviewed with full text.</p>`;
                return;
            }

            reviewedArticles.forEach(article => {
                finalReviewListEl.innerHTML += renderFinalReviewCard(article);
            });
        }

        // --- Document Upload/Preview Functions ---
        
        function formatBytes(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        function createFileCard(fileName, content) {
            const isAuto = fileName.startsWith('AUTO_');
            const fileSource = isAuto ? 
                `<span class="text-xs font-semibold text-green-600">Auto-Retrieved (PMC)</span>` :
                `<span class="text-xs font-semibold text-purple-600">Manually Uploaded</span>`;

            const previewText = content.substring(0, 1000) + (content.length > 1000 ? '...\n\n[Content truncated for preview]' : '');
            const escapedContent = JSON.stringify(content);

            const sizeDisplay = isAuto ? 'Size: N/A' : `Size: ${formatBytes(new TextEncoder().encode(content).length)}`;

            return `
                <div class="file-card p-4 rounded-xl shadow-md border-l-4 ${isAuto ? 'border-green-500 bg-green-50' : 'border-purple-500 bg-white'}">
                    <div class="flex items-center justify-between mb-3 border-b pb-2">
                        <h3 class="text-lg font-bold text-gray-700 truncate mr-4">${fileName}</h3>
                        ${fileSource}
                    </div>
                    <p class="text-xs text-gray-500 mb-2">${sizeDisplay}</p>

                    <div class="bg-gray-50 p-3 rounded-lg border border-gray-200">
                        <p class="text-sm font-semibold text-gray-700 mb-1">Preview (First ${Math.min(1000, content.length)} Chars)</p>
                        <pre class="custom-scrollbar text-xs text-gray-800 bg-white p-2 rounded-md overflow-auto max-h-40 whitespace-pre-wrap break-words border border-gray-300">
${previewText}
                        </pre>
                    </div>

                    <div class="mt-3 flex justify-end">
                        <button onclick='window.copyToClipboard("${fileName}", ${escapedContent})' 
                                class="copy-btn px-3 py-1 bg-purple-500 text-white text-xs font-medium rounded-full hover:bg-purple-600 transition-colors duration-200 shadow-md">
                            Copy Full Text
                        </button>
                    </div>
                </div>
            `;
        }
        
        window.copyToClipboard = (fileName, content) => {
            const textarea = document.createElement('textarea');
            textarea.value = content;
            document.body.appendChild(textarea);
            textarea.select();
            
            const btn = event.target;

            try {
                document.execCommand('copy');
                const originalText = btn.textContent;
                btn.textContent = 'Copied!';
                btn.classList.remove('bg-purple-500', 'hover:bg-purple-600');
                btn.classList.add('bg-green-500', 'hover:bg-green-600');
                
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.classList.add('bg-purple-500', 'hover:bg-purple-600');
                    btn.classList.remove('bg-green-500', 'hover:bg-green-600');
                }, 1500);

            } catch (err) {
                console.error('Could not copy text: ', err);
                updateStatus('Failed to copy text to clipboard.', 'error');
            } finally {
                document.body.removeChild(textarea);
            }
        }
        
        // --- Helper function to read PDF content ---
        async function readPdfToText(file) {
            try {
                const arrayBuffer = await file.arrayBuffer();
                const pdf = await window.pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                let fullText = '';
                
                for (let i = 1; i <= pdf.numPages; i++) {
                    const page = await pdf.getPage(i);
                    const textContent = await page.getTextContent();
                    const pageText = textContent.items.map(item => item.str).join(' ');
                    fullText += pageText + '\n';
                }
                return fullText;
            } catch (error) {
                console.error("Error parsing PDF:", error);
                throw new Error("Failed to parse PDF file.");
            }
        }

        // Renders both manually uploaded and auto-retrieved files
        function renderFullTextUploadStatus() {
            const fileListContainer = document.getElementById('fileListContainer');
            const initialMessage = document.getElementById('initialMessage');
            const startReviewBtn = document.getElementById('start-full-text-review-button');
            
            const fileNames = Object.keys(appState.uploadedTexts);

            if (fileNames.length === 0) {
                fileListContainer.innerHTML = '';
                initialMessage.style.display = 'block';
                startReviewBtn.classList.add('hidden');
                return;
            }

            fileListContainer.innerHTML = '';
            initialMessage.style.display = 'none';

            // Sort files to show auto-retrieved first
            fileNames.sort((a, b) => (a.startsWith('AUTO_') === b.startsWith('AUTO_')) ? 0 : a.startsWith('AUTO_') ? -1 : 1);

            fileNames.forEach(fileName => {
                const content = appState.uploadedTexts[fileName];
                fileListContainer.innerHTML += createFileCard(fileName, content);
            });
            
            // Show the review button if any file was successfully loaded
            startReviewBtn.classList.remove('hidden');
        }


        window.handleFileSelect = async () => {
            const fileInput = document.getElementById('fileInput');
            const files = fileInput.files;

            if (files.length === 0) {
                // If user cancels, we don't clear auto-retrieved files
                renderFullTextUploadStatus();
                return;
            }

            // Clear only manual uploads, keep auto-retrieved ones
            Object.keys(appState.uploadedTexts).forEach(key => {
                if (!key.startsWith('AUTO_')) {
                    delete appState.uploadedTexts[key];
                }
            });

            const fileListContainer = document.getElementById('fileListContainer');
            
            const fileArray = Array.from(files);
            
            for (const file of fileArray) {
                const isTextFile = file.type.startsWith('text/') || /\.(txt|md|log|csv)$/i.test(file.name);
                const isPdfFile = file.type === 'application/pdf' || file.name.endsWith('.pdf');

                if (!isTextFile && !isPdfFile) {
                    console.warn(`Skipping unsupported file: ${file.name}`);
                    continue;
                }

                const fileName = file.name;

                // Add a placeholder card immediately
                const loadingCard = document.createElement('div');
                loadingCard.id = `loading-${fileName.replace(/[\s\.]/g, '-')}`;
                loadingCard.className = "bg-yellow-50 p-4 rounded-xl shadow-md border border-yellow-300 animate-pulse";
                loadingCard.innerHTML = `<p class="text-yellow-700 font-medium text-sm">Loading & Parsing: ${fileName}...</p>`;
                fileListContainer.appendChild(loadingCard);

                try {
                    let content = '';
                    if (isPdfFile) {
                        content = await readPdfToText(file);
                    } else {
                         // Read text file
                        content = await new Promise((resolve, reject) => {
                            const reader = new FileReader();
                            reader.onload = (e) => resolve(e.target.result);
                            reader.onerror = (e) => reject(e.target.error);
                            reader.readAsText(file);
                        });
                    }
                    
                    appState.uploadedTexts[fileName] = content; // Store the content
                    
                } catch (error) {
                    console.error("Error reading file:", error);
                    // We can show an error card if we want, or just log it
                } finally {
                    // Remove loading card
                    document.getElementById(`loading-${fileName.replace(/[\s\.]/g, '-')}`)?.remove();
                }
            }
            // Re-render all at the end
            renderFullTextUploadStatus();
        }


        // --- Core Logic & Handlers ---

        window.handleOverride = (pmid) => {
            const article = appState.articles.find(a => a.PMID === pmid);
            if (article) {
                article.Override = true;
                renderResults();
                updateStatus(`PMID ${pmid} has been manually included. Please re-review the final included list.`, 'info');
            }
        };

        async function handleCriteriaGeneration(event) {
            event.preventDefault();
            document.getElementById('review-panel').classList.add('hidden');
            document.getElementById('results-panel').classList.add('hidden');
            document.getElementById('upload-panel').classList.add('hidden');
            document.getElementById('full-text-review-panel').classList.add('hidden');
            document.getElementById('report-panel').classList.add('hidden');
            document.getElementById('modification-panel').classList.add('hidden');
            document.getElementById('prisma-panel').classList.add('hidden');
            
            const researchQuestion = document.getElementById('research-question').value.trim();
            const dateLimit = document.getElementById('date-limit').value.trim();
            
            if (!researchQuestion) {
                updateStatus('Please enter a research question first.', 'error');
                return;
            }

            appState.dateLimit = dateLimit ? parseInt(dateLimit) : null;

            const llmOutput = await generateCriteriaAndQuery(researchQuestion);

            if (llmOutput) {
                document.getElementById('pubmed-query').value = llmOutput.SuggestedPubmedQuery || '';
                
                // Display PICO if available
                if (llmOutput.PICO) {
                    document.getElementById('pico-p').textContent = llmOutput.PICO.Population || 'N/A';
                    document.getElementById('pico-i').textContent = llmOutput.PICO.Intervention || 'N/A';
                    document.getElementById('pico-c').textContent = llmOutput.PICO.Comparison || 'N/A';
                    document.getElementById('pico-o').textContent = llmOutput.PICO.Outcome || 'N/A';
                    document.getElementById('pico-container').classList.remove('hidden');
                } else {
                     document.getElementById('pico-container').classList.add('hidden');
                }

                const criteriaJson = JSON.stringify({
                    Inclusion: llmOutput.Inclusion,
                    Exclusion: llmOutput.Exclusion
                }, null, 2);
                document.getElementById('inclusion-criteria').value = criteriaJson;
                
                appState.criteria = {
                    Inclusion: llmOutput.Inclusion,
                    Exclusion: llmOutput.Exclusion
                };
                appState.pubmedQuery = llmOutput.SuggestedPubmedQuery;
                
                document.getElementById('review-panel').classList.remove('hidden');
            }
        }

        async function startScreening(event) {
            event.preventDefault();
            setButtonLoading('start-screening-button', true);
            document.getElementById('results-panel').classList.add('hidden');
            document.getElementById('upload-panel').classList.add('hidden');
            document.getElementById('full-text-review-panel').classList.add('hidden');
            document.getElementById('report-panel').classList.add('hidden'); 
            document.getElementById('modification-panel').classList.add('hidden');
            document.getElementById('prisma-panel').classList.add('hidden');
            appState.articles = [];
            appState.uploadedTexts = {}; // Clear previous uploads/auto-retrieved
            appState.currentDraft = '';
            document.getElementById('slr-draft-output').innerHTML = '';
            document.getElementById('retrieval-status-message').classList.add('hidden');

            const queryInput = document.getElementById('pubmed-query');
            const criteriaInput = document.getElementById('inclusion-criteria');

            try {
                updateStatus('Starting process. Validating user-refined criteria...', 'info');
                appState.criteria = JSON.parse(criteriaInput.value);
                appState.pubmedQuery = queryInput.value;

                const uids = await fetchPubmedUids(appState.pubmedQuery, appState.dateLimit);
                if (uids.length === 0) {
                    updateStatus("No articles found for that query or date range.", 'info');
                    setButtonLoading('start-screening-button', false);
                    return;
                }
                let rawArticles = await fetchAbstracts(uids);

                updateStatus(`**Starting AI abstract screening for ${rawArticles.length} articles.** This step uses the Gemini API for analysis.`, 'process');
                
                const screeningPromises = rawArticles.map(article => {
                    return screenArticle(article, appState.criteria).then(llmResult => {
                        return { ...article, ...llmResult };
                    });
                });

                appState.articles = await Promise.all(screeningPromises);

                renderResults();
                updateStatus(`Abstract screening complete! ${appState.articles.length} total articles reviewed. Proceed to Step 4.`, 'success');

            } catch (error) {
                console.error("Screening process failed:", error);
                updateStatus(`An error occurred: ${error.message}. Check your criteria JSON format or try a different query.`, 'error');
            } finally {
                setButtonLoading('start-screening-button', false);
            }
        }

        window.exportResults = () => {
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(appState.articles, null, 2));
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            downloadAnchorNode.setAttribute("download", "slr_screening_results.json");
            document.body.appendChild(downloadAnchorNode);
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
            updateStatus('Screening results exported as JSON.', 'info');
        }

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('criteria-form').addEventListener('submit', handleCriteriaGeneration);
            document.getElementById('screening-form').addEventListener('submit', startScreening);
            document.getElementById('generate-report-button').addEventListener('click', generateSLRReport);
            document.getElementById('refine-report-button').addEventListener('click', refineSLRReport); 
            // Note: generatePrismaDiagram is called via onclick attribute
            updateStatus('Enter your research question and click "Generate Criteria & PubMed Query" to start.', 'info');
        });

    </script>
</body>
</html>

